### 8-11随笔

#### async 与 await 和 promise

- `promise`简单的来说就是一个容器, 里面保存着未来才会结束的时间(一般是一个异步操作的结果)
- `promise`对象的状态不受外界改变
- 一旦状态改变, 就不会在变,状态就只有`reslove`,`,rejected`了
- `promise`的`then `是为`promise`实例添加状态改变时的回调函数. 参数可以有两个 `resolve` 与 `rejected`
- `catch` 用于改变状态为 `rejected` 时的回调函数, 可以被认为时 then(null, func2) 的简写形式
- `promise.all` 方法用于将多个`promise` 的实例, 包装成一个新的`promise` 实例, 成功和失败返回的数据类型是不相同的, 当所有的状态为成功状态时才返回数组, 只要其中有一个rejected的,就返回reject的值
- `promise.rece` 同样时将多个方法包装为一个新的`promise` 实例, 不同的是哪个对象返回的快就返回哪个对象, 如果对象其中有`rejected`状态的，必须`catch`捕捉到，如果返回的够快，就返回这个状态。
- `async`表示这里是一个 `async` 函数, `await` 只能在这个函数里面使用.
- `await` 表示在这里等待 `promise` 返回结果后, 在继续执行,
- `await` 后面跟着的应该是一个`promise` 对象
- 也就是说`await` 是强制把异步变成了同步, 这一句代码执行完, 才会执行下一句,
- 一旦遇到`await`就会先返回,等到触发的异步操作完成,再接着执行函数体后面的语句
- 如果他等到的不是一个Promise 对象, 那await 表达式的运算结果就是它等到的东西
- 如果它等到的是一个promise 对象,await就忙起来了, 他会阻塞后面的代码,等着,`promise` 对象 `reslove`, 然后得到`reslove`的值, 作为 `await`表达式的运算结果
- 阻塞的只是当前路径并不阻塞其他代码的路径,不然异步就没有什么意义了



#### 浅析 `javaScript` 执行机制

`Javascript`是单线程语言, 一切`javascript`版的"多线程"都是用单线程模拟出来的,因为`javascript`是单线程这一核心没有改变

既然`javascript` 是单线程 就像买东西一样,需要结账排队,需要等前面的人结完,才可以进行下一个人,那么问题来了，假如我们想浏览新闻，但是新闻包含的超清图片加载很慢，难道我们的网页要一直卡着直到图片完全显示出来？因此 `javascript` 将任务分为两类：

- ##### 同步任务

- ##### 异步任务

当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。

##### 1. 进入任务执行栈

##### 2. 判断是同步还是异步任务 如果是同步 就是主线程 异步的话就放到 事件列表 注册回调函数 当回调函数完成后把这个异步任务放入 事件列队等待主线程的任务执行完毕后执行, 当主线程的任务执行完毕后 会去Event Queue 事件列队 读取相应的函数,进入主线程执行.

##### 3.这个过程会无限的重复,也就是所谓的事件循环

- **macro-task**(宏任务)：包括整体代码`script`，`setTimeout`，`setInterval`
- **micro-task**(微任务)：`Promise`，`process.nextTick`

不同类型的任务会进入对应的Event Queue，比如`setTimeout`和`setInterval`会进入相同的Event Queue。

第一次进入`script`宏任务列队中, 开始第一次循环, 宏任务执行结束, 查看有没有可执行的微任务, 没有开始新的微任务, 有的话就执行所有的微任务 简单的说 就是在当前上下文执行完所有的主线程任务, 遇到一个宏任务,把他放到宏任务列队, 遇到一个微任务,把它放到微任务列队, 归类完成后,开始进入主线程执行 先去执行 微任务的 Event Queue ,所有微任务执行完毕之后,开始执行宏任务,以此类推 ....  

#### Token Cookie Session

- `token`  完全由应用管理,所以它可以避开同源策略
- token 可以避免`CSRF` 攻击
- Token 可以是无状态的,可以在 多个服务间共享 

Token,是由服务端产生的, 前端使用用户名密码向服务端请求认证,服务端认证成功,那么在服务端会返回token 给前端,前端每次请求带上证明自己的合法地位.

`cookie` 是为了解决服务器的压力 出现的解决方案, 