### `vue`源码随笔

#### 响应式

##### 什么是响应式呢?

简单的来说就是视图变化,页面也随即变化.

##### 怎么实现的呢?

在`javascript`中有一个`object.defineProperty`中有两个属性,分别为`get, `set`,对对象的属性进行读取或操作时,就会触发get,和set.

为了使对象所有的属性变得可观测,在`vue`中有一个`Observer`的类,用于将一个正常的object转化成可观测的object,也就是说,只要将一个`object`传到`observer` 中,那么这个object,就会变得可观测,响应式的object。

这下数据变得可观测了,变得可观测以后,我们就能知道数据什么发生了变化,当数据发生变化时,就去通知视图更新,那么问题又来了,视图这么大,需要向谁传达指令呢?一个数据变化,去更新所有视图,这样的做法显然是不合理的。

我们给每一个数据都建一个依赖数组,谁依赖(用)到了这个数据,我们就把谁放入这个数组依赖中,那么当这个数据发生变化的时侯,我们就去它对应的依赖数组中,把每个依赖都通知一遍,通知他们去更新,这个过程就是依赖收集

##### 何时收集依赖,何时通知依赖

谁用到了这个数据,那么当这个数据变化时就通知谁. 所谓谁用到了这个数据,其实就是谁获取了这个数据,而观测的数据被获取时会触发getter属性,那么我们就可以在getter中收集这个依赖,同样当这个数据变化时会触发setter属性,那么我们就可以在setter中通知依赖更新

##### 总结: 在getter中收集依赖, 在setter中通知依赖更新

##### 把依赖收集到哪里?

我们为每一个数据都建立一个依赖管理器,把这个数据所有的依赖都管理起来.

于是就有一个Dep类诞生了!

![image-20200809161616555](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20200809161616555.png)

在上面的依赖管理器`Dep`类中,我们先初始化了一个`subs`数组,用来存放依赖,并且定义了几个实例方法,用来对依赖进行添加,删除,通知等操作.

![image-20200809162439446](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20200809162439446.png)

##### 依赖到底是谁?

我们一直再说,"谁"用到了这个数据谁就是依赖",在`vue`中还实现了一个叫做`Watcher`的类,而`Watcher`类的实例就是我们所说的那个"谁",简单来说,视图上谁用到了数据,谁就是依赖,我们就为谁创建一个`Watcher`实例,在之后数据变化时,我们不直接去通知依赖的更新,而是通知依赖对应的`Watch`实例,由`Watcher`实例去通知真正的视图,

![image-20200809165534803](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20200809165534803.png)

视图上谁用到了数谁就是依赖,我们就为谁创建一个`watcher`实例,在创建`Watcher`实例过程中会自动把自己添加到这个数据对应的依赖管理器中

